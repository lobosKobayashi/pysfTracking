EnclosureGrp を設けるのではなく、np.array(...,) を直接に扱う
↑ そうしないで EnclosreGrp(np.ndarray) とする方法もある
    ↑zeros などは独自に実装しなければならない。
        ↑ 実装していない ndarray 操作はできなくなる。
            np.r_[..] など
    ↑ SvTxt クラスと fnSvTxt、 SvRect クラスと fnSvRect の両方が必要になる
    ↑Layout class を設ければ
    Layout([5mm*'yes', 10mm*'→', 5mm*'NO']).__str__()
    Layout(SvRect,[5mm*'yes', 10mm*'→', 5mm*'NO']).__str__()
    ↑SvRect.arrDefaultMergin = mm ~[5,10,5,10]
    Layout([5mm*'YES', 10mm*'→', 5mm*'NO']).svg()
    Layout(SvRect,[5mm*'yes', 10mm*'→', 5mm*'NO']).svg()

    Layout([5mm'yes', 10mm'→', 5mm'NO'])
    Layout(SvRect, [5mm'yes', 10mm'→', 5mm'NO'])

    vc=5mm'YES → NO'; vc[1]*=2; Layout(vc)
    ↑ Layout ではなく
    AllignedGroup(arAg, dx=(10mm, 15mm, ...))
    or
    AllignedGroup(arAg, dx=[10mm]*3)


date:2015/11/11 (水) time:21:42
抽象的な allocate は 配列、array 要素にテキストを設定した段階で終わっている

Enclosure
    self.m_arInsert=None    # determined after lay
    self.m_arSize=

NestedEnclosure:
×Allocation
SvAlignment(array or matrix, x=..., y=)
↑Sv を付けるのを止める。運用するときに付ける
    ↑ np と同じ
    ↑ ShortHand をソースに定義しておく
ks module 名にする

ksv(); ksv

svm:suport vector machine は sfCrrntIni.py 中で import sklearn.svm as svm をやった

class SvTxt(svg.text.Text) は class Text(svg.text.Text) に変更する。
↑kSvTxt.py ファイルの中のクラスであり Sv 接頭語を付ける意味を見出せない

svg.text.Text は下の属性を持つ。ksv.Text は、これを継承し size ベクトルと C, N,E,S,W,.. 属性を持つ
    def __init__(self, text, insert=None, x=None, y=None, dx=None, dy=None, rotate=None,**ag)
↑svg.text.Text には size 属性はない。insert で文字列の左下位置を指定するだけだ。
    ↑厳密には renderer が描いてみないと、表示領域は定まらない
        ↑ IE,FireFox で文字列のサイズが 同じ font-family でも 数% のオーダーでは変わっている。


# test は bool 値テストに限定することで、既存の kVerifier 実装をそのまま利用する

# SvgUnit:SUt shorthanded
## とりあえず mm, cm, px
## 文字列または SvgText との左側掛け算による SvgText を生成する
### 足し算・掛け算は左側優先
### int/float の左右掛け算も許す。このときはサイズが増える。
↑ svg の scale の働きを SvgText でも可能にする
#### 0SvgUnit * str or SvgText は 0SvgText とする。c:center 属性しか持たない m_mtfourCorner は None 

# SvgText
## SvgText については入れ子構造を認めない
### SvgText(svgText) は、やはり SvgText instance にする。
↓↑ この二種類にしとかないと仕様を詰めきれない。← SvgText(svgTextGroup) は assert error にしておく
    ↑ 5mm [sTt,sTt, sTg] で、何を返すか決め切れん。
### 別に SvgTextGroup を設けて、こちらで SvgText の入れ子構造を扱えるようにする
↑ 引数が 

# SvgText の配置は numpy array container によって行う
↑ numpy array に拘るのは、配置修正機能が実装済みだから。← transpose, 上下左右逆転など
    ↑Sb(..), Cy(..) による入れ替え操作も可能
    ↑ 足し算･掛け算 行列操作まで可能だが、それのテストまでは行わない。
## sequence 構造 -- 縦と横 基準線:path
## matrix   構造 --- 面:null 要素の海の中に配置する
## tree 構造
## 入れ子構造
### 文字を置く位置の上下左右を下の四種類で定める
    ~[svgTxt instance, nested container] 
    ~[svgTxt instance, nested container].t 
    ~[nested container, svgTxt instance] 
    ~[nested container, svgTxt instance].t 



# Enclosing class;;SvRect, SvCircle, SvOval .... は svgTxt 及び そのコンテナを引数として生成される。
↑Enclosure クラスと EnclosueGroup(np.ndarra) クラスの二種類を設ける。
↑ 四隅の寸法が決まっていれば enclose できる
    ↑ SvArrow の四隅の寸法は lazy evalation とする
        ↑ left, right position, stroke_width が決められてから定められる。
## primitive class として EnClosure class を設けて、SvRect などは これを継承させる
m_mtFourSide, C,N,E,S,W, NE,SE,SW,NW 属性を持つ。

## Enclosing class は SvgText グループ:tuple,list, arry, krry も引数とできる。


# default 値
## left,right, upper, lower margin
## left,right, upper, lower spacing
↑ どこに持たせる。Enclosre に basic な default 値を持たせる
    ↑ SvgRect にも同じ default 値を持たせ、 Enclosure の値を override する


# string 行列に SvSize を掛ける扱いが consistent に可能
x=np.array(['abc', 'de']); x, x.dtype
===============================
(array(['abc', 'de'], 

x=np.array([2,3]); ts(); y=1m` x; y, y.dtype
===============================
(array([2*m`, 3*m`], dtype=object), dtype('O'))


* 実装メモ
*** 全角文字の処理
**** determination of full/half size characters
# 全角・半角判定
 Javaにおいては文字列は全てUNICODEで表現されるため、全角半角の判定も各文字のUNICODEで判断する他ありません。以下のサンプルように判定します。

public class Hankaku {
    public static void main() {
        String s = "全角han漢字\\~〜ｶﾅ";
        System.out.print( s+": " );
        for( int i=0; i<s.length(); i++ ) {
            char c = s.charAt( i );
            if( ( c<='\u007e' )|| // 英数字
                ( c=='\u00a5' )|| // \記号
                ( c=='\u203e' )|| // ~記号
                ( c>='\uff61' && c<='\uff9f' ) // 半角カナ
            )
                System.out.print( "半" );
            else
                System.out.print( "全" );
        }
        System.out.print( "\n" );
    }
}

Stringから一文字づつ取り出し、個々の文字のUNICODEを比較します。Javaでは文字を表す時は、'\u007e'のように'（シングルクォート）で囲みます。

実行結果は以下のようになります。

全角han漢字\~〜ｶﾅ: 全全半半半全全半半全半半 	

** invalid implementation
**** SvSizef
mm, px などの svg unit size を扱うクラス SvSize は float を継承したかった。__new__(cls,...) でなんとかできると思っていた。
↑ でも def __mul__(self,..) 関数を実装できなかった。組み込み関数も変更できないよう。

class Svg_pxSize(float):
    def __new__(cls, strAg, flAg):
        float.__new__(cls,flAg) 
        cls.m_strUnit = 'px'
        cls.m_flUnit = 1

        cls.__rmul__ = Svg_pxSize.__rmul__
        cls.__mul__ = Svg_pxSize.__mul__

        return cls

    def __rmul__(self, flAg):
        assert( isinstance(flAg,(int, float)) ), (
            "In Svg_pxSize.__rmul__, you set unexpected value:"+ str(flAg))
        return Svg_pxSize(flAg)

    def __flaot__(self):
        return self.m_fl

    def __mul__(self,ag):
        #pass      # detect right multiplyer
        return float(self)*ag

    def __str__(self):
        return str(self)+'px'

px=Svg_pxSize('px', 1)

* invalid specifications
** EnclosureGroup は止める。
ユーザーが明示的に np.array 要素として Enclosure Element を配置する

